// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createJob = `-- name: CreateJob :one
insert into tiny.job(run_at, name, state, status, executor)
values (
   $1,
   $2,
   $3,
   'READY',
   $4
)
returning id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor
`

type CreateJobParams struct {
	RunAt    interface{}
	Name     sql.NullString
	State    sql.NullString
	Executor string
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (TinyJob, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.RunAt,
		arg.Name,
		arg.State,
		arg.Executor,
	)
	var i TinyJob
	err := row.Scan(
		&i.ID,
		&i.RunAt,
		&i.Name,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.ExecutionAmount,
		&i.Timeout,
		&i.Status,
		&i.State,
		&i.Executor,
	)
	return i, err
}

const deleteJobByID = `-- name: DeleteJobByID :one
delete from tiny.job
where id = $1
returning id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor
`

func (q *Queries) DeleteJobByID(ctx context.Context, id int64) (TinyJob, error) {
	row := q.db.QueryRow(ctx, deleteJobByID, id)
	var i TinyJob
	err := row.Scan(
		&i.ID,
		&i.RunAt,
		&i.Name,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.ExecutionAmount,
		&i.Timeout,
		&i.Status,
		&i.State,
		&i.Executor,
	)
	return i, err
}

const deleteJobByName = `-- name: DeleteJobByName :one
delete from tiny.job
where name = $1
returning id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor
`

func (q *Queries) DeleteJobByName(ctx context.Context, name sql.NullString) (TinyJob, error) {
	row := q.db.QueryRow(ctx, deleteJobByName, name)
	var i TinyJob
	err := row.Scan(
		&i.ID,
		&i.RunAt,
		&i.Name,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.ExecutionAmount,
		&i.Timeout,
		&i.Status,
		&i.State,
		&i.Executor,
	)
	return i, err
}

const fetchDueJobs = `-- name: FetchDueJobs :many
update tiny.job as updated_jobs
set status      = 'PENDING',
    last_run_at = now()
from (
    select id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor
    from tiny.job
    where tiny.is_due(run_at, coalesce(last_run_at, created_at), now())
    and status = 'READY'
    -- worker limit
    limit $1 for update
    skip locked
) as due_jobs
where due_jobs.id = updated_jobs.id
returning updated_jobs.id, updated_jobs.run_at, updated_jobs.name, updated_jobs.last_run_at, updated_jobs.created_at, updated_jobs.execution_amount, updated_jobs.timeout, updated_jobs.status, updated_jobs.state, updated_jobs.executor
`

// TODO: Add check for not running ever a job if
// `last_run_at` happened less than x seconds ago
func (q *Queries) FetchDueJobs(ctx context.Context, limit int32) ([]TinyJob, error) {
	rows, err := q.db.Query(ctx, fetchDueJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TinyJob
	for rows.Next() {
		var i TinyJob
		if err := rows.Scan(
			&i.ID,
			&i.RunAt,
			&i.Name,
			&i.LastRunAt,
			&i.CreatedAt,
			&i.ExecutionAmount,
			&i.Timeout,
			&i.Status,
			&i.State,
			&i.Executor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByID = `-- name: GetJobByID :one
select id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor from tiny.job
where id = $1 limit 1
`

func (q *Queries) GetJobByID(ctx context.Context, id int64) (TinyJob, error) {
	row := q.db.QueryRow(ctx, getJobByID, id)
	var i TinyJob
	err := row.Scan(
		&i.ID,
		&i.RunAt,
		&i.Name,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.ExecutionAmount,
		&i.Timeout,
		&i.Status,
		&i.State,
		&i.Executor,
	)
	return i, err
}

const getJobByName = `-- name: GetJobByName :one
select id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor from tiny.job
where name = $1 limit 1
`

func (q *Queries) GetJobByName(ctx context.Context, name sql.NullString) (TinyJob, error) {
	row := q.db.QueryRow(ctx, getJobByName, name)
	var i TinyJob
	err := row.Scan(
		&i.ID,
		&i.RunAt,
		&i.Name,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.ExecutionAmount,
		&i.Timeout,
		&i.Status,
		&i.State,
		&i.Executor,
	)
	return i, err
}

const searchJobs = `-- name: SearchJobs :many
select id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor from tiny.job
where name like concat($3::text, '%')
or name like concat('%', $3::text)
offset $1
limit $2
`

type SearchJobsParams struct {
	Offset int32
	Limit  int32
	Query  string
}

// TODO: This query is not working wit dynamic params ðŸ¤”
func (q *Queries) SearchJobs(ctx context.Context, arg SearchJobsParams) ([]TinyJob, error) {
	rows, err := q.db.Query(ctx, searchJobs, arg.Offset, arg.Limit, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TinyJob
	for rows.Next() {
		var i TinyJob
		if err := rows.Scan(
			&i.ID,
			&i.RunAt,
			&i.Name,
			&i.LastRunAt,
			&i.CreatedAt,
			&i.ExecutionAmount,
			&i.Timeout,
			&i.Status,
			&i.State,
			&i.Executor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobByID = `-- name: UpdateJobByID :one

update tiny.job
set run_at = coalesce(nullif($2, ''), run_at),
    state = coalesce(nullif($3, ''), state)
where id = $1
returning id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor
`

type UpdateJobByIDParams struct {
	ID    int64
	RunAt interface{}
	State interface{}
}

// TODO: Should refactor usage of `name`
func (q *Queries) UpdateJobByID(ctx context.Context, arg UpdateJobByIDParams) (TinyJob, error) {
	row := q.db.QueryRow(ctx, updateJobByID, arg.ID, arg.RunAt, arg.State)
	var i TinyJob
	err := row.Scan(
		&i.ID,
		&i.RunAt,
		&i.Name,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.ExecutionAmount,
		&i.Timeout,
		&i.Status,
		&i.State,
		&i.Executor,
	)
	return i, err
}

const updateJobByName = `-- name: UpdateJobByName :one

update tiny.job
set run_at = coalesce(nullif($2, ''), run_at),
    state = coalesce(nullif($3, ''), state)
where name = $1
returning id, run_at, name, last_run_at, created_at, execution_amount, timeout, status, state, executor
`

type UpdateJobByNameParams struct {
	Name  sql.NullString
	RunAt interface{}
	State interface{}
}

// TODO: Implement search
func (q *Queries) UpdateJobByName(ctx context.Context, arg UpdateJobByNameParams) (TinyJob, error) {
	row := q.db.QueryRow(ctx, updateJobByName, arg.Name, arg.RunAt, arg.State)
	var i TinyJob
	err := row.Scan(
		&i.ID,
		&i.RunAt,
		&i.Name,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.ExecutionAmount,
		&i.Timeout,
		&i.Status,
		&i.State,
		&i.Executor,
	)
	return i, err
}
